<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Location Management - TIMS</title>
  <link rel="stylesheet" href="styles.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css"/>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">
  <style>
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 2rem;
    }
    .map-container {
      width: 100%;
      height: 500px;
      border: 2px solid #0a8806;
      border-radius: 1rem;
      overflow: hidden;
      display: none; /* Initially hidden */
      position: relative; /* Add position relative */
      min-height: 500px; /* Ensure minimum height */
    }
    #map {
      width: 100% !important;
      height: 100% !important;
      position: absolute !important;
      top: 0;
      left: 0;
    }
    .enrolled-areas {
      margin-top: 2rem;
    }
    .area-card {
      border: 1px solid #ddd;
      border-radius: 8px;
      margin-bottom: 1rem;
      padding: 1rem;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    .area-card:hover {
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      border-color: #0a8806;
    }
    .area-card.active {
      border-color: #0a8806;
      background-color: #f0f9f0;
    }
    .area-map {
      height: 200px;
      margin-top: 1rem;
      border-radius: 4px;
      overflow: hidden;
    }
    .btn-enroll {
      background: #0a8806;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 1rem;
      font-weight: 600;
      margin-bottom: 2rem;
    }
    .btn-enroll:hover {
      background: #097205;
    }
    .drawing-instructions {
      display: none;
      text-align: center;
      color: #0a8806;
      margin: 1rem 0;
      padding: 1rem;
      background: #f0f9f0;
      border-radius: 4px;
    }
    .btn-save {
      display: none;
      background: #0a8806;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      margin: 1rem 0;
    }
    .btn-cancel {
      display: none;
      background: #666;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      margin: 1rem 0;
      margin-left: 1rem;
    }
    .btn-cancel:hover {
      background: #555;
    }
    .map-actions {
      display: flex;
      justify-content: flex-start;
      align-items: center;
      margin: 1rem 0;
      z-index: 100; /* Ensure container is above map */
      position: relative; /* Enable z-index */
    }
    .no-areas {
      text-align: center;
      padding: 2rem;
      color: #666;
      font-style: italic;
    }
    .tree-marker {
      background-color: #0a8806;
      border: 2px solid white;
      border-radius: 50%;
      width: 12px;
      height: 12px;
      box-shadow: 0 0 4px rgba(0,0,0,0.3);
    }
    .area-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .area-list-item {
      display: flex;
      align-items: center;
      padding: 1rem;
      border: 1px solid #ddd;
      border-radius: 8px;
      margin-bottom: 1rem;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .area-list-item:hover {
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      border-color: #0a8806;
    }

    .area-list-item.active {
      border-color: #0a8806;
      background-color: #f0f9f0;
    }

    .area-info {
      flex-grow: 1;
    }

    .area-title {
      font-size: 1.1rem;
      font-weight: 600;
      color: #333;
      margin: 0 0 0.5rem 0;
    }

    .area-date {
      font-size: 0.9rem;
      color: #666;
    }

    .btn-view-details {
      background: #0a8806;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9rem;
    }

    .btn-view-details:hover {
      background: #097205;
    }

    /* Modal styles */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 1000;
    }

    .modal-content {
      position: relative;
      background: white;
      width: 90%;
      max-width: 1000px;
      margin: 2rem auto;
      padding: 2rem;
      border-radius: 8px;
      max-height: 90vh;
      overflow-y: auto;
    }

    .close-modal {
      position: absolute;
      top: 1rem;
      right: 1rem;
      font-size: 1.5rem;
      cursor: pointer;
      color: #666;
    }

    .close-modal:hover {
      color: #333;
    }

    .modal-map {
      height: 400px;
      margin: 1rem 0;
      border-radius: 8px;
      border: 2px solid #0a8806;
    }

    .area-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin: 1rem 0;
    }

    .stat-card {
      background: #f8f9fa;
      padding: 1rem;
      border-radius: 8px;
      text-align: center;
    }

    .stat-value {
      font-size: 1.5rem;
      font-weight: 600;
      color: #0a8806;
      margin: 0.5rem 0;
    }

    .stat-label {
      font-size: 0.9rem;
      color: #666;
    }

    .tree-list {
      margin-top: 1rem;
    }

    .tree-list-title {
      font-size: 1.2rem;
      margin-bottom: 1rem;
    }

    .tree-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 1rem;
    }

    .tree-card {
      border: 1px solid #ddd;
      border-radius: 8px;
      margin-bottom: 1rem;
      padding: 1rem;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .tree-card:hover {
      border-color: #0a8806;
      background-color: #f0f9f0;
    }
    
    .tree-card.active {
      border-color: #0a8806;
      background-color: #f0f9f0;
    }
    
    .tree-details {
      display: none;
      margin-top: 1rem;
      padding: 1rem;
      background: #f8f9fa;
      border-radius: 8px;
    }
    
    .tree-details.show {
      display: block;
    }
    
    .tree-detail-item {
      padding: 0.5rem;
      border-bottom: 1px solid #eee;
    }
    
    .tree-detail-item:last-child {
      border-bottom: none;
    }
    
    .back-to-types {
      display: none;
      background: #0a8806;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      margin-bottom: 1rem;
    }
    
    .back-to-types:hover {
      background: #097205;
    }

    .user-location-dot {
      background: transparent;
    }
    .pulse {
      width: 20px;
      height: 20px;
      background: #0a8806;
      border-radius: 50%;
      position: relative;
      animation: pulse 1.5s ease-in-out infinite;
    }
    .pulse:after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: 50%;
      border: 2px solid #0a8806;
      animation: pulse-ring 1.5s ease-in-out infinite;
    }
    @keyframes pulse {
      0% {
        transform: scale(0.5);
      }
      50% {
        transform: scale(1);
      }
      100% {
        transform: scale(0.5);
      }
    }
    @keyframes pulse-ring {
      0% {
        transform: scale(0.3);
        opacity: 0.8;
      }
      100% {
        transform: scale(2);
        opacity: 0;
      }
    }

    /* Loading Spinner Styles */
    .loading-container {
      display: none;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(255, 255, 255, 0.9);
      z-index: 1000;
      justify-content: center;
      align-items: center;
      flex-direction: column;
    }
    
    .loading-spinner {
      width: 50px;
      height: 50px;
      border: 5px solid #f3f3f3;
      border-top: 5px solid #0a8806;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    .loading-text {
      margin-top: 1rem;
      color: #0a8806;
      font-weight: 600;
      font-size: 1.1rem;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .filter-container {
      display: flex;
      align-items: center;
      margin-bottom: 1rem;
      padding: 0.5rem;
      background: #f8f9fa;
      border-radius: 4px;
    }

    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 60px;
      height: 34px;
      margin-left: 1rem;
    }

    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: .4s;
      border-radius: 34px;
    }

    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 26px;
      width: 26px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }

    input:checked + .toggle-slider {
      background-color: #0a8806;
    }

    input:checked + .toggle-slider:before {
      transform: translateX(26px);
    }

    .endemic-badge {
      background-color: #0a8806;
      color: white;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 0.8em;
      margin-left: 0.5rem;
    }

    .tree-card.endemic {
      border-left: 4px solid #0a8806;
      background-color: #f0f9f0;
    }

    .tree-type {
      font-weight: 600;
      color: #333;
      display: flex;
      align-items: center;
      margin-bottom: 0.5rem;
    }

    /* Weather control styles */
    .weather-control {
      background: white;
      padding: 10px;
      border-radius: 4px;
      box-shadow: 0 1px 5px rgba(0,0,0,0.4);
      margin-bottom: 10px;
    }
    
    .weather-icon {
      width: 50px;
      height: 50px;
      margin-right: 10px;
      vertical-align: middle;
    }
    
    .weather-info {
      display: flex;
      align-items: center;
      margin-bottom: 5px;
    }
    
    .weather-details {
      font-size: 0.9rem;
      color: #333;
    }
    
    .weather-temp {
      font-size: 1.2rem;
      font-weight: 600;
      color: #0a8806;
    }
    
    .weather-description {
      text-transform: capitalize;
    }
    
    .weather-refresh {
      background: #0a8806;
      color: white;
      border: none;
      padding: 5px 10px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.8rem;
      margin-top: 5px;
    }
    
    .weather-refresh:hover {
      background: #097205;
    }
    
    .weather-options {
      margin-top: 10px;
    }
    
    .weather-toggle {
      margin-right: 10px;
    }

    /* Building Availability Checker Styles */
    .btn-check-availability {
      background: #0a8806;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9rem;
      margin-left: 0.5rem;
    }

    .btn-check-availability:hover {
      background: #097205;
    }

    .building-instructions {
      display: none;
      text-align: center;
      color: #0a8806;
      margin: 1rem 0;
      padding: 1rem;
      background: #f0f9f0;
      border-radius: 4px;
    }

    .btn-confirm-location {
      display: none;
      background: #0a8806;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      margin: 1rem 0;
    }

    .building-result {
      margin-top: 1rem;
      padding: 1rem;
      border-radius: 4px;
      display: none;
    }

    .result-allowed {
      background-color: #f0f9f0;
      border: 1px solid #0a8806;
    }

    .result-warning {
      background-color: #fff9e6;
      border: 1px solid #ffc107;
    }

    .result-denied {
      background-color: #ffebee;
      border: 1px solid #f44336;
    }

    .affected-trees {
      margin-top: 1rem;
      max-height: 300px;
      overflow-y: auto;
      padding: 0.5rem;
      background: #f8f9fa;
      border-radius: 4px;
    }

    .affected-tree-item {
      padding: 0.5rem;
      border-bottom: 1px solid #eee;
      display: flex;
      align-items: center;
    }

    .affected-tree-item:last-child {
      border-bottom: none;
    }

    .tree-status-icon {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      margin-right: 0.5rem;
      flex-shrink: 0;
    }

    .status-protected {
      background-color: #f44336;
    }

    .status-permit {
      background-color: #ffc107;
    }

    .status-allowed {
      background-color: #0a8806;
    }

    .building-zone {
      opacity: 0.5;
      stroke-dasharray: 5, 5;
      stroke-width: 2;
      stroke: #333;
    }

    .building-form {
      margin-top: 1rem;
      padding: 1rem;
      background: #f8f9fa;
      border-radius: 4px;
    }

    .form-group {
      margin-bottom: 1rem;
    }

    .form-label {
      display: block;
      margin-bottom: 0.5rem;
      font-weight: 600;
    }

    .form-input {
      width: 100%;
      padding: 0.5rem;
      border: 1px solid #ddd;
      border-radius: 4px;
    }

    .form-select {
      width: 100%;
      padding: 0.5rem;
      border: 1px solid #ddd;
      border-radius: 4px;
    }

    .steps-container {
      margin-top: 1rem;
      padding: 1rem;
      background: #f8f9fa;
      border-radius: 4px;
    }

    .step-item {
      margin-bottom: 1rem;
      padding-bottom: 1rem;
      border-bottom: 1px solid #eee;
    }

    .step-item:last-child {
      margin-bottom: 0;
      padding-bottom: 0;
      border-bottom: none;
    }

    .step-number {
      display: inline-block;
      width: 24px;
      height: 24px;
      background: #0a8806;
      color: white;
      border-radius: 50%;
      text-align: center;
      line-height: 24px;
      margin-right: 0.5rem;
    }

    .step-title {
      font-weight: 600;
      margin-bottom: 0.5rem;
    }

    .step-description {
      margin-left: 2rem;
      font-size: 0.9rem;
    }

    /* Building Availability Modal */
    .building-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 2000; /* Increased z-index to ensure it's above the map */
    }

    .building-modal-content {
      position: relative;
      background: white;
      width: 90%;
      max-width: 1000px;
      margin: 2rem auto;
      padding: 2rem;
      border-radius: 8px;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      z-index: 2001; /* Higher than modal backdrop */
    }

    /* Make sure the map doesn't cover the modal */
    #map {
      z-index: 1; /* Lower z-index */
    }

    /* Availability Overlay Styles */
    .availability-toggle {
      position: relative;
      display: flex;
      align-items: center;
      margin-top: 1rem;
    }

    .availability-legend {
      display: none;
      margin-top: 1rem;
      padding: 0.5rem;
      background: #f8f9fa;
      border-radius: 4px;
      font-size: 0.9rem;
    }

    .legend-item {
      display: flex;
      align-items: center;
      margin-bottom: 0.5rem;
    }

    .legend-color {
      width: 20px;
      height: 20px;
      margin-right: 0.5rem;
      border-radius: 3px;
      border: 1px solid rgba(0,0,0,0.2);
    }

    .legend-available {
      background-color: rgba(10, 136, 6, 0.2);
    }

    .legend-permit {
      background-color: rgba(255, 193, 7, 0.3);
    }

    .legend-restricted {
      background-color: rgba(244, 67, 54, 0.3);
    }

    .availability-grid {
      position: absolute;
      pointer-events: none;
    }

    .grid-cell {
      position: absolute;
      border: 1px solid rgba(255, 255, 255, 0.3);
      cursor: pointer;
      pointer-events: all;
      transition: background-color 0.2s ease-in-out;
    }

    .cell-available {
      background-color: rgba(10, 136, 6, 0.2);
    }

    .cell-permit-required {
      background-color: rgba(255, 193, 7, 0.3);
    }

    .cell-restricted {
      background-color: rgba(244, 67, 54, 0.3);
    }

    .grid-cell:hover {
      opacity: 0.8;
      box-shadow: inset 0 0 0 2px #fff;
    }

    .cell-tooltip {
      position: absolute;
      background: white;
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 0.8rem;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      z-index: 1000;
      pointer-events: none;
      max-width: 200px;
    }

    .btn-show-availability {
      background: #0a8806;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9rem;
      margin-top: 0.5rem;
      display: inline-block !important; /* Ensure button is always displayed */
      margin-left: 0.5rem;
      z-index: 100; /* Ensure button is above other elements */
      position: relative; /* Enable z-index */
    }

    .btn-show-availability:hover {
      background: #097205;
    }
    
    /* Add specific button states */
    .btn-show-availability.active {
      background: #d32f2f;
    }
    
    .btn-show-availability.active:hover {
      background: #b71c1c;
    }
    
    .resolution-control {
      margin-left: 1rem;
      width: 120px;
    }
    
    /* Result banner styles */
    .result-banner {
      padding: 15px;
      border-radius: 4px;
      margin-bottom: 15px;
      display: flex;
      align-items: center;
      font-size: 1.1em;
    }
    
    .result-banner i {
      margin-right: 10px;
      font-size: 1.5em;
    }
    
    .red-result {
      background-color: #ffe9e9;
      color: #d32f2f;
      border-left: 5px solid #d32f2f;
    }
    
    .yellow-result {
      background-color: #fff9e6;
      color: #f57c00;
      border-left: 5px solid #f57c00;
    }
    
    .green-result {
      background-color: #e6fff0;
      color: #0a8806;
      border-left: 5px solid #0a8806;
    }
  </style>
  <!-- Add some style fixes to ensure the maps display correctly -->
  <style>
    #modalMapContainer {
      width: 100%;
      height: 400px;
      border: 1px solid #ddd;
      border-radius: 4px;
      margin-bottom: 15px;
      position: relative;
      z-index: 1;
      display: block !important;
    }
    
    .leaflet-container {
      z-index: 1;
    }
    
    .building-modal {
      z-index: 2000 !important;
    }
    
    .building-modal-content {
      z-index: 2001 !important;
    }
    
    /* Ensure modal map is visible */
    .building-modal-content .leaflet-container {
      height: 400px !important;
      width: 100% !important;
      z-index: 1;
    }
    
    /* Fix for the modal map rendering */
    #buildingMapArea {
      position: relative;
      overflow: visible;
    }
    
    /* Make sure buttons are visible */
    .building-buttons-container {
      display: flex !important;
      gap: 10px;
      justify-content: center;
      margin-top: 15px;
    }
    
    .building-buttons-container .btn-save,
    .building-buttons-container .btn-cancel {
      display: inline-block !important;
      padding: 12px 24px;
      font-size: 16px;
      opacity: 1 !important;
      visibility: visible !important;
    }
    
    /* Area modal map fixes */
    #modalMap {
      width: 100% !important;
      height: 400px !important;
      position: relative !important;
      display: block !important;
      z-index: 1;
    }
    
    .modal-map .leaflet-container {
      height: 400px !important;
      width: 100% !important;
    }
    
    .modal {
      z-index: 1500 !important;
    }
    
    .modal-content {
      z-index: 1501 !important;
    }
    
    /* Fix for map not being visible in modals due to z-index issues */
    .leaflet-pane {
      z-index: 400 !important;
    }
    
    .leaflet-control-container .leaflet-top {
      z-index: 410 !important;
    }
    
    .leaflet-control-container .leaflet-bottom {
      z-index: 410 !important;
    }
    
    /* Building modal map fixes */
    #modalMapContainer {
      width: 100% !important;
      height: 400px !important;
      position: relative !important;
      display: block !important;
      z-index: 1;
      border: 1px solid #ccc;
      margin: 10px 0;
    }
    
    #modalMapContainer .leaflet-container {
      height: 400px !important;
      width: 100% !important;
    }
    
    .building-modal {
      z-index: 1600 !important;
    }
    
    .building-modal-content {
      z-index: 1601 !important;
    }
    
    /* Fix for map not being visible in modals due to z-index issues */
    .leaflet-pane {
      z-index: 400 !important;
    }
    
    .leaflet-control-container .leaflet-top {
      z-index: 410 !important;
    }
    
    .leaflet-control-container .leaflet-bottom {
      z-index: 410 !important;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Location Management</h1>
    <button id="btnStartEnroll" class="btn-enroll">Enroll New Location</button>
    
    <div class="map-actions">
      <button id="btnSaveArea" class="btn-save">Save Area</button>
      <button id="btnCancelEnroll" class="btn-cancel">Cancel</button>
    </div>
    
    <div class="drawing-instructions" id="drawingInstructions">
      Draw your area on the map by clicking points to create a polygon. Click the first point to complete the shape.
    </div>
    
    <div class="map-container" id="mapContainer">
      <div class="loading-container" id="mapLoading">
        <div class="loading-spinner"></div>
        <div class="loading-text">Loading map...</div>
      </div>
      <div id="map" style="width:100%;height:100%"></div>
    </div>

    <div class="enrolled-areas">
      <h2>Your Enrolled Areas</h2>
      <ul id="areasList" class="area-list">
        <li class="no-areas">No areas enrolled yet. Click "Enroll New Location" to get started.</li>
      </ul>
    </div>
  </div>

  <!-- Area Details Modal -->
  <div id="areaModal" class="modal">
    <div class="modal-content">
      <span class="close-modal" onclick="closeModal()">&times;</span>
      <h2 id="modalTitle">Area Details</h2>
      <div class="area-stats">
        <div class="stat-card">
          <div class="stat-value" id="perimeterValue">0</div>
          <div class="stat-label">Perimeter (meters)</div>
        </div>
        <div class="stat-card">
          <div class="stat-value" id="treeCountValue">0</div>
          <div class="stat-label">Trees</div>
        </div>
        <div class="stat-card">
          <div class="stat-value" id="areaValue">0</div>
          <div class="stat-label">Area (sq. meters)</div>
        </div>
      </div>
      <div id="modalMap" class="modal-map"></div>
      <div class="tree-list">
        <button id="backToTypes" class="back-to-types">Back to Tree Types</button>
        <h3 class="tree-list-title">Trees in this Area</h3>
        <div id="treeGrid" class="tree-grid">
          <!-- Tree cards will be added here -->
        </div>
        <div id="treeDetails" class="tree-details">
          <!-- Tree details will be added here -->
        </div>
      </div>
    </div>
  </div>

  <!-- Building Availability Modal -->
  <div id="buildingModal" class="building-modal">
    <div class="building-modal-content">
      <span class="close-modal" onclick="closeBuildingModal()">&times;</span>
      <h2 id="buildingModalTitle">Check Building Availability</h2>
      
      <div class="building-form" id="buildingForm">
        <div class="form-group">
          <label class="form-label" for="structureType">Structure Type:</label>
          <select class="form-select" id="structureType">
            <option value="residential">Residential Building</option>
            <option value="commercial">Commercial Building</option>
            <option value="agricultural">Agricultural Structure</option>
            <option value="infrastructure">Infrastructure Project</option>
          </select>
        </div>
        
        <div class="form-group">
          <label class="form-label" for="structureSize">Estimated Size (sq. meters):</label>
          <input type="number" class="form-input" id="structureSize" min="1" placeholder="Enter size">
        </div>
        
        <div class="form-group">
          <label class="form-label" for="projectDescription">Project Description:</label>
          <textarea class="form-input" id="projectDescription" rows="3" placeholder="Brief description of your project"></textarea>
        </div>
        
        <div class="form-group" style="margin-top: 25px;">
          <button type="button" id="btnSelectLocation" onclick="startLocationSelection()" class="btn-save" style="display: block; width: 100%; padding: 15px; font-size: 16px; font-weight: bold; cursor: pointer;">
            Select Location on Map
          </button>
        </div>
        
        <div id="useSelectedCellContainer" style="margin-top: 10px;"></div>
      </div>
      
      <div class="building-instructions" id="buildingInstructions" style="display:none; margin-top: 20px;">
        <p>Click on the map to place your building location, then drag to set the size.</p>
        <div id="modalMapContainer" style="width: 100%; height: 400px; border: 1px solid #ddd; border-radius: 4px; margin: 15px 0;"></div>
        <div style="text-align: center; margin-bottom: 10px; font-size: 0.8em;">
          <button onclick="resetModalMap()" style="background: #f8f9fa; border: 1px solid #ddd; padding: 5px 10px; border-radius: 4px; cursor: pointer;">
            Map not showing? Click to reset
          </button>
        </div>
        <div class="building-buttons-container" style="margin-top: 15px; display: flex !important; gap: 10px; justify-content: center;">
          <button type="button" onclick="confirmDrawing()" class="btn-save" style="display: inline-block !important; padding: 12px 24px; font-size: 16px;">Confirm Location</button>
          <button type="button" onclick="cancelLocationSelection()" class="btn-cancel" style="display: inline-block !important; padding: 12px 24px; font-size: 16px;">Cancel</button>
        </div>
      </div>
      
      <div class="building-result" id="buildingResult" style="display:none;">
        <h3 id="resultTitle">Building Availability Result</h3>
        <p id="resultMessage"></p>
        
        <div id="affectedTreesContainer" style="display: none;">
          <h4>Affected Trees:</h4>
          <div class="affected-trees" id="affectedTrees"></div>
        </div>
        
        <div id="stepsContainer" class="steps-container" style="display: none;">
          <h4>Required Steps:</h4>
          <div id="requiredSteps"></div>
        </div>
      </div>
    </div>
  </div>

  <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
  <script>
    let map;
    let drawControl;
    let drawnItems;
    let activeArea = null;
    let treeMarkers = null;
    let modalMap = null;
    let userLocationMarker = null;
    let weatherLayer = null;
    let currentWeather = null;
    let buildingLayer = null;
    let buildingMode = false;
    let currentArea = null;
    let buildingPolygon = null;
    let availabilityOverlay = null;
    let gridCells = [];
    let tooltipElement = null;
    let activeOverlayArea = null;
    let gridResolution = 10; // Default grid resolution (meters)
    
    // Initialize variables
    document.addEventListener('DOMContentLoaded', function() {
      const authToken = localStorage.getItem('authToken');
      const userId = localStorage.getItem('user_id');
      
      if (!authToken || !userId) {
        window.location.href = 'index.html';
        return;
      }

      // Load enrolled areas immediately
      loadEnrolledAreas();
      
      // Initialize buildingLayer to prevent "undefined" errors
      buildingLayer = L.featureGroup();
    });

    // Promise wrapper for geolocation with better accuracy and retry logic
    function getCurrentPosition(retryCount = 0, maxRetries = 2) {
      return new Promise((resolve, reject) => {
        if (!navigator.geolocation) {
          reject(new Error('Geolocation is not supported by your browser'));
          return;
        }

        // Geolocation options
        const options = {
          enableHighAccuracy: true,  // Request best possible position
          timeout: 10000,            // Wait up to 10 seconds
          maximumAge: 0              // Always get fresh position
        };

        // Success handler with accuracy check
        const successHandler = (position) => {
          // Check if accuracy is reasonable (within 100 meters)
          if (position.coords.accuracy <= 100) {
            resolve(position);
          } else if (retryCount < maxRetries) {
            // If accuracy is poor and we haven't hit max retries, try again
            console.log(`Poor accuracy (${position.coords.accuracy}m), retrying...`);
            setTimeout(() => {
              getCurrentPosition(retryCount + 1, maxRetries)
                .then(resolve)
                .catch(reject);
            }, 1000);
          } else {
            // If we've hit max retries, use the best position we got
            console.log(`Using position with accuracy: ${position.coords.accuracy}m`);
            resolve(position);
          }
        };

        // Error handler with retry logic
        const errorHandler = (error) => {
          if (retryCount < maxRetries) {
            // If we haven't hit max retries, try again
            console.log(`Geolocation error (${error.message}), retrying...`);
            setTimeout(() => {
              getCurrentPosition(retryCount + 1, maxRetries)
                .then(resolve)
                .catch(reject);
            }, 1000);
          } else {
            // If we've hit max retries, return the error
            console.error('Geolocation failed after retries:', error);
            reject(error);
          }
        };

        // Start geolocation request
        navigator.geolocation.getCurrentPosition(
          successHandler,
          errorHandler,
          options
        );
      });
    }

    // Helper function to check if coordinates are valid
    function isValidCoordinate(lat, lng) {
      return (
        typeof lat === 'number' && 
        typeof lng === 'number' && 
        !isNaN(lat) && 
        !isNaN(lng) && 
        lat >= -90 && 
        lat <= 90 && 
        lng >= -180 && 
        lng <= 180
      );
    }

    // Initialize map with user's location
    async function initMap() {
      try {
        const mapContainer = document.getElementById('mapContainer');
        const mapElement = document.getElementById('map');
        const loadingElement = document.getElementById('mapLoading');
        
        // Show loading animation
        loadingElement.style.display = 'flex';
        
        // Ensure map container is visible before initialization
        mapContainer.style.display = 'block';

        // Palawan bounds (covers the entire island and surrounding areas)
        const palawanBounds = L.latLngBounds(
          [8.3, 117.0], // Southwest corner
          [12.5, 119.5]  // Northeast corner
        );
        
        // Default coordinates (Puerto Princesa)
        let initialLat = 9.9672;
        let initialLng = 118.7855;
        let initialZoom = 9;
        let locationSource = 'default';

        // Try to get cached position first
        const cachedLat = localStorage.getItem('lastLat');
        const cachedLng = localStorage.getItem('lastLng');
        if (cachedLat && cachedLng && isValidCoordinate(parseFloat(cachedLat), parseFloat(cachedLng))) {
          // Only use cached coordinates if they're within Palawan bounds
          const cachedLatNum = parseFloat(cachedLat);
          const cachedLngNum = parseFloat(cachedLng);
          if (palawanBounds.contains([cachedLatNum, cachedLngNum])) {
            initialLat = cachedLatNum;
            initialLng = cachedLngNum;
            locationSource = 'cache';
          }
        }

        // Try to get current position
        if ("geolocation" in navigator) {
          try {
            const position = await getCurrentPosition();
            if (isValidCoordinate(position.coords.latitude, position.coords.longitude)) {
              // Only use current location if it's within Palawan bounds
              if (palawanBounds.contains([position.coords.latitude, position.coords.longitude])) {
                initialLat = position.coords.latitude;
                initialLng = position.coords.longitude;
                initialZoom = 15;
                locationSource = 'current';
                
                // Cache the successful position
                localStorage.setItem('lastLat', initialLat.toString());
                localStorage.setItem('lastLng', initialLng.toString());
              }
            }
          } catch (error) {
            console.error("Error getting location:", error);
            // Continue with existing coordinates
          }
        }

        console.log(`Using ${locationSource} location:`, { lat: initialLat, lng: initialLng });

        // Create map instance with the determined location
        if (map) {
          map.remove(); // Clean up existing map instance if it exists
          map = null;
        }

        map = L.map('map', {
          zoomControl: true,
          maxZoom: 19,
          minZoom: 8,
          preferCanvas: true,
          maxBounds: palawanBounds.pad(0.1), // Add 10% padding to bounds
          maxBoundsViscosity: 1.0, // Make bounds completely solid
          bounceAtZoomLimits: false
        });

        // Force a map refresh before setting view
        map.invalidateSize();
        
        // Set view after invalidateSize, but constrain to bounds
        const initialLatLng = L.latLng(initialLat, initialLng);
        const constrainedLatLng = initialLatLng.wrap();
        if (!palawanBounds.contains(constrainedLatLng)) {
          // If location is outside bounds, center on Puerto Princesa
          map.setView([9.9672, 118.7855], 9);
        } else {
          map.setView([initialLat, initialLng], initialZoom);
        }

        // Add tile layer with loading optimization
        const tileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          attribution: '© OpenStreetMap contributors',
          updateWhenIdle: true,
          updateWhenZooming: false,
          maxNativeZoom: 19,
          maxZoom: 19,
          minZoom: 8,
          keepBuffer: 2,
          bounds: palawanBounds, // Only load tiles within Palawan bounds
          noWrap: true // Prevent tile wrapping around the globe
        }).addTo(map);

        // Hide loading when tiles are loaded
        tileLayer.on('load', function() {
          loadingElement.style.display = 'none';
        });

        // Set a maximum timeout for loading
        setTimeout(() => {
          loadingElement.style.display = 'none';
        }, 5000);

        // Initialize layers
        if (!drawnItems) {
          drawnItems = new L.FeatureGroup();
          map.addLayer(drawnItems);
        }
        
        if (!treeMarkers) {
          treeMarkers = L.layerGroup();
          map.addLayer(treeMarkers);
        }
        
        if (!buildingLayer) {
          buildingLayer = L.featureGroup();
          map.addLayer(buildingLayer);
        }
        
        // Add location marker with accuracy circle
        if (userLocationMarker) {
          userLocationMarker.remove();
        }
        userLocationMarker = L.circle([initialLat, initialLng], {
          color: '#0a8806',
          fillColor: '#0a8806',
          fillOpacity: 0.2,
          radius: locationSource === 'current' ? 100 : 500, // Larger radius for non-current location
          weight: 2
        }).addTo(map);

        // Add a pulsing dot for current location
        if (locationSource === 'current') {
          const pulsingDot = L.divIcon({
            className: 'user-location-dot',
            html: '<div class="pulse"></div>',
            iconSize: [20, 20]
          });
          L.marker([initialLat, initialLng], {
            icon: pulsingDot,
            zIndexOffset: 1000
          }).addTo(map);
        }

        // Initialize draw control
        drawControl = new L.Control.Draw({
          draw: {
            polygon: {
              allowIntersection: false,
              showArea: true,
              drawError: {
                color: '#e1e100',
                message: '<strong>Cannot draw intersecting polygon!</strong>'
              },
              shapeOptions: {
                color: '#0a8806'
              }
            },
            circle: false,
            circlemarker: false,
            marker: false,
            polyline: false,
            rectangle: false
          },
          edit: {
            featureGroup: drawnItems,
            remove: false
          }
        });

        // Add draw created event listener
        map.on('draw:created', function(e) {
          drawnItems.clearLayers();
          const layer = e.layer;
          drawnItems.addLayer(layer);
          document.getElementById('btnSaveArea').style.display = 'block';
        });

        // Add weather control to map
        addWeatherControl(map, initialLat, initialLng);

        // Force another map refresh after everything is set up
        setTimeout(() => {
          map.invalidateSize();
          map.setView([initialLat, initialLng], initialZoom);
        }, 250);

      } catch (error) {
        console.error("Error initializing map:", error);
        const mapContainer = document.getElementById('mapContainer');
        const loadingElement = document.getElementById('mapLoading');
        mapContainer.style.display = 'none';
        loadingElement.style.display = 'none';
        throw new Error(`Map initialization failed: ${error.message}`);
      }
    }

    // Add weather control to map
    function addWeatherControl(map, lat, lng) {
      // Create custom control
      const WeatherControl = L.Control.extend({
        options: {
          position: 'topright'
        },
        
        onAdd: function(map) {
          const container = L.DomUtil.create('div', 'weather-control');
          container.innerHTML = `
            <div id="weatherInfo">
              <div class="weather-info">
                <img id="weatherIcon" class="weather-icon" src="" alt="Weather">
                <div>
                  <div id="weatherTemp" class="weather-temp">--°C</div>
                  <div id="weatherDesc" class="weather-description">Loading weather...</div>
                </div>
              </div>
              <div id="weatherDetails" class="weather-details">
                <div>Humidity: <span id="weatherHumidity">--%</span></div>
                <div>Wind: <span id="weatherWind">-- km/h</span></div>
              </div>
              <button id="refreshWeather" class="weather-refresh">Refresh</button>
              <div class="weather-options">
                <label class="weather-toggle">
                  <input type="checkbox" id="weatherOverlay"> Show weather overlay
                </label>
              </div>
            </div>
          `;
          
          // Prevent propagation of map events
          L.DomEvent.disableClickPropagation(container);
          L.DomEvent.disableScrollPropagation(container);
          
          // Add event listeners after the control is added to the map
          setTimeout(() => {
            document.getElementById('refreshWeather').addEventListener('click', function() {
              fetchWeather(lat, lng);
            });
            
            document.getElementById('weatherOverlay').addEventListener('change', function(e) {
              toggleWeatherOverlay(e.target.checked);
            });
            
            // Initial weather fetch
            fetchWeather(lat, lng);
          }, 0);
          
          return container;
        }
      });
      
      // Add control to map
      map.addControl(new WeatherControl());
    }

    // Fetch weather data from OpenWeatherMap API
    async function fetchWeather(lat, lng) {
      try {
        // Update UI to show loading
        document.getElementById('weatherDesc').textContent = 'Loading weather...';
        
        // OpenWeatherMap API key - normally would be kept server-side for security
        // This is a placeholder API key, you'll need to get your own from openweathermap.org
        const apiKey = 'YOUR_API_KEY'; // Replace with your actual API key
        
        // Skip API call if using the default placeholder key
        if (apiKey === 'YOUR_API_KEY') {
          document.getElementById('weatherDesc').textContent = 'API key not configured';
          document.getElementById('weatherTemp').textContent = '--°C';
          document.getElementById('weatherHumidity').textContent = '--%';
          document.getElementById('weatherWind').textContent = '-- km/h';
          
          // Disable the weather overlay checkbox
          const weatherOverlayCheckbox = document.getElementById('weatherOverlay');
          if (weatherOverlayCheckbox) {
            weatherOverlayCheckbox.disabled = true;
            weatherOverlayCheckbox.checked = false;
          }
          
          return;
        }
        
        // Fetch weather data
        const response = await fetch(`https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lng}&units=metric&appid=${apiKey}`);
        
        if (!response.ok) {
          throw new Error('Weather data not available');
        }
        
        const data = await response.json();
        currentWeather = data;
        
        // Update weather UI
        document.getElementById('weatherIcon').src = `https://openweathermap.org/img/wn/${data.weather[0].icon}@2x.png`;
        document.getElementById('weatherTemp').textContent = `${Math.round(data.main.temp)}°C`;
        document.getElementById('weatherDesc').textContent = data.weather[0].description;
        document.getElementById('weatherHumidity').textContent = `${data.main.humidity}%`;
        document.getElementById('weatherWind').textContent = `${Math.round(data.wind.speed * 3.6)} km/h`; // Convert m/s to km/h
        
        // If weather overlay is enabled, update it
        if (document.getElementById('weatherOverlay').checked) {
          updateWeatherOverlay(data);
        }
        
        console.log('Weather updated successfully');
      } catch (error) {
        console.error('Error fetching weather:', error);
        document.getElementById('weatherDesc').textContent = 'Weather unavailable';
      }
    }

    // Toggle weather overlay on the map
    function toggleWeatherOverlay(show) {
      if (show && currentWeather) {
        updateWeatherOverlay(currentWeather);
      } else if (weatherLayer) {
        map.removeLayer(weatherLayer);
        weatherLayer = null;
      }
    }

    // Update weather overlay on the map
    function updateWeatherOverlay(weatherData) {
      // Remove existing weather layer if any
      if (weatherLayer) {
        map.removeLayer(weatherLayer);
      }
      
      // Create weather overlay based on conditions
      const weather = weatherData.weather[0].main.toLowerCase();
      let overlayOptions = {
        opacity: 0.5,
        attribution: 'Weather data: OpenWeatherMap'
      };
      
      // Different overlay styles based on weather condition
      if (weather.includes('rain') || weather.includes('drizzle')) {
        // Blue overlay for rain
        weatherLayer = L.rectangle(map.getBounds(), {
          color: '#0044ff',
          fillColor: '#0044ff',
          fillOpacity: 0.2,
          weight: 0
        }).addTo(map);
        
        // Add rain effect
        addRainEffect();
      } else if (weather.includes('cloud')) {
        // Gray overlay for clouds
        weatherLayer = L.rectangle(map.getBounds(), {
          color: '#888888',
          fillColor: '#888888',
          fillOpacity: 0.15,
          weight: 0
        }).addTo(map);
      } else if (weather.includes('clear')) {
        // Yellow/orange overlay for clear sky
        weatherLayer = L.rectangle(map.getBounds(), {
          color: '#ffbb00',
          fillColor: '#ffbb00',
          fillOpacity: 0.05,
          weight: 0
        }).addTo(map);
      } else if (weather.includes('fog') || weather.includes('mist')) {
        // White overlay for fog
        weatherLayer = L.rectangle(map.getBounds(), {
          color: '#ffffff',
          fillColor: '#ffffff',
          fillOpacity: 0.3,
          weight: 0
        }).addTo(map);
      }
      
      // Update layer when map is moved
      map.on('moveend', function() {
        if (weatherLayer) {
          map.removeLayer(weatherLayer);
          updateWeatherOverlay(currentWeather);
        }
      });
    }

    // Add rain effect to the map
    function addRainEffect() {
      // Lightweight rain effect using CSS
      const mapContainer = document.getElementById('map');
      const rainContainer = document.createElement('div');
      rainContainer.id = 'rainEffect';
      rainContainer.style.cssText = `
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 400;
      `;
      
      // Create raindrops
      for (let i = 0; i < 100; i++) {
        const raindrop = document.createElement('div');
        raindrop.style.cssText = `
          position: absolute;
          width: 1px;
          height: ${5 + Math.random() * 10}px;
          background: rgba(200, 200, 255, 0.6);
          left: ${Math.random() * 100}%;
          top: ${Math.random() * 100}%;
          animation: rain-fall ${0.5 + Math.random() * 1}s linear infinite;
          opacity: ${0.4 + Math.random() * 0.6};
        `;
        rainContainer.appendChild(raindrop);
      }
      
      // Add animation keyframes
      const style = document.createElement('style');
      style.textContent = `
        @keyframes rain-fall {
          0% { transform: translateY(-20px) rotate(10deg); }
          100% { transform: translateY(20px) rotate(10deg); }
        }
      `;
      document.head.appendChild(style);
      
      // Add to map
      mapContainer.appendChild(rainContainer);
      
      // Remove rain effect when weather changes
      map.on('layerremove', function(e) {
        if (e.layer === weatherLayer) {
          const rainEffect = document.getElementById('rainEffect');
          if (rainEffect) {
            rainEffect.remove();
          }
        }
      });
    }

    // Update weather when user location changes
    function updateWeatherForLocation(lat, lng) {
      fetchWeather(lat, lng);
    }

    // Start enrollment process
    document.getElementById('btnStartEnroll').addEventListener('click', async function() {
      try {
        const mapContainer = document.getElementById('mapContainer');
        const drawingInstructions = document.getElementById('drawingInstructions');
        const btnCancelEnroll = document.getElementById('btnCancelEnroll');
        const loadingElement = document.getElementById('mapLoading');
        
        // Show necessary elements immediately
        mapContainer.style.display = 'block';
        drawingInstructions.style.display = 'block';
        btnCancelEnroll.style.display = 'block';
        this.style.display = 'none';
        
        // Initialize map if not exists
        if (!map) {
          loadingElement.style.display = 'flex';
          await initMap();
        }

        // Remove existing draw control if present
        if (drawControl && map.drawControl) {
          map.removeControl(drawControl);
          map.drawControl = null;
        }

        // Clear any existing layers
        drawnItems.clearLayers();
        
        // Initialize draw control immediately
        drawControl = new L.Control.Draw({
          draw: {
            polygon: {
              allowIntersection: false,
              showArea: true,
              drawError: {
                color: '#e1e100',
                message: '<strong>Cannot draw intersecting polygon!</strong>'
              },
              shapeOptions: {
                color: '#0a8806'
              }
            },
            circle: false,
            circlemarker: false,
            marker: false,
            polyline: false,
            rectangle: false
          },
          edit: {
            featureGroup: drawnItems,
            remove: false
          }
        });

        // Add draw control to map
        map.addControl(drawControl);
        map.drawControl = drawControl;

        // Ensure draw:created event listener is set
        map.off('draw:created'); // Remove any existing listeners
        map.on('draw:created', function(e) {
          drawnItems.clearLayers();
          const layer = e.layer;
          drawnItems.addLayer(layer);
          document.getElementById('btnSaveArea').style.display = 'block';
        });

        // Try to get current location
        if ("geolocation" in navigator) {
          try {
            loadingElement.style.display = 'flex';
            const position = await getCurrentPosition();
            if (isValidCoordinate(position.coords.latitude, position.coords.longitude)) {
              // Force map refresh before updating view
              map.invalidateSize();
              map.setView([position.coords.latitude, position.coords.longitude], 15, { animate: false });
              
              if (userLocationMarker) {
                userLocationMarker.setLatLng([position.coords.latitude, position.coords.longitude]);
              } else {
                userLocationMarker = L.circle([position.coords.latitude, position.coords.longitude], {
                  color: '#0a8806',
                  fillColor: '#0a8806',
                  fillOpacity: 0.2,
                  radius: 100,
                  weight: 2
                }).addTo(map);
              }

              // Update weather for new location
              updateWeatherForLocation(position.coords.latitude, position.coords.longitude);

              // Cache the successful position
              localStorage.setItem('lastLat', position.coords.latitude.toString());
              localStorage.setItem('lastLng', position.coords.longitude.toString());
            }
          } catch (error) {
            console.error("Error updating location:", error);
          } finally {
            loadingElement.style.display = 'none';
          }
        }

        // Clear any active area selection
        if (activeArea) {
          const previousActiveCard = document.querySelector('.area-card.active');
          if (previousActiveCard) {
            previousActiveCard.classList.remove('active');
          }
          activeArea = null;
          treeMarkers.clearLayers();
        }

        // Hide save button until area is drawn
        document.getElementById('btnSaveArea').style.display = 'none';

        // Final map refresh
        setTimeout(() => {
          map.invalidateSize();
        }, 100);
        
      } catch (error) {
        console.error("Error in enrollment process:", error);
        // Reset UI state
        const mapContainer = document.getElementById('mapContainer');
        const drawingInstructions = document.getElementById('drawingInstructions');
        const btnCancelEnroll = document.getElementById('btnCancelEnroll');
        const btnStartEnroll = document.getElementById('btnStartEnroll');
        const loadingElement = document.getElementById('mapLoading');
        
        mapContainer.style.display = 'none';
        drawingInstructions.style.display = 'none';
        btnCancelEnroll.style.display = 'none';
        btnStartEnroll.style.display = 'block';
        loadingElement.style.display = 'none';
        
        alert("There was an error starting the enrollment process. Please try again. Error: " + error.message);
      }
    });

    // Cancel enrollment process
    document.getElementById('btnCancelEnroll').addEventListener('click', function() {
      const mapContainer = document.getElementById('mapContainer');
      mapContainer.style.display = 'none';
      document.getElementById('btnStartEnroll').style.display = 'block';
      document.getElementById('btnSaveArea').style.display = 'none';
      document.getElementById('btnCancelEnroll').style.display = 'none';
      document.getElementById('drawingInstructions').style.display = 'none';
      
      if (map) {
        drawnItems.clearLayers();
        map.removeControl(drawControl);
      }
    });

    // Save drawn area
    document.getElementById('btnSaveArea').addEventListener('click', async function() {
      try {
        const areas = [];
        drawnItems.eachLayer(function(layer) {
          if (layer instanceof L.Polygon) {
            areas.push(layer.getLatLngs()[0].map(latlng => [latlng.lat, latlng.lng]));
          }
        });

        if (areas.length === 0) {
          alert('Please draw an area first');
          return;
        }

        const response = await fetch('save_enrolled_area.php', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${localStorage.getItem('authToken')}`,
            'X-User-ID': localStorage.getItem('user_id')
          },
          body: JSON.stringify({
            coordinates: areas[0]
          })
        });

        const data = await response.json();
        if (data.success) {
          alert('Area saved successfully!');
          await loadEnrolledAreas();
          drawnItems.clearLayers();
          map.removeControl(drawControl);
          document.getElementById('btnStartEnroll').style.display = 'block';
          document.getElementById('btnSaveArea').style.display = 'none';
          document.getElementById('btnCancelEnroll').style.display = 'none';
          document.getElementById('drawingInstructions').style.display = 'none';
          document.getElementById('mapContainer').style.display = 'none';
        } else {
          throw new Error(data.message || 'Failed to save area');
        }
      } catch (error) {
        console.error('Error saving area:', error);
        alert('Failed to save area. Please try again.');
      }
    });

    // Load enrolled areas
    async function loadEnrolledAreas() {
      try {
        const authToken = localStorage.getItem('authToken');
        const userId = localStorage.getItem('user_id');

        if (!authToken || !userId) {
          console.error('Missing authentication data:', { authToken: !!authToken, userId: !!userId });
          window.location.href = 'index.html';
          return;
        }

        console.log('Fetching enrolled areas with:', { userId });
        const response = await fetch('get_enrolled_areas.php', {
          headers: {
            'Authorization': `Bearer ${authToken}`,
            'X-User-ID': userId,
            'Content-Type': 'application/json'
          }
        });

        if (!response.ok) {
          const errorText = await response.text();
          console.error('Server response not ok:', {
            status: response.status,
            statusText: response.statusText,
            errorText
          });
          throw new Error(`Server returned ${response.status}: ${response.statusText}`);
        }

        const result = await response.json();
        console.log('Received areas data:', result);

        if (!result.success) {
          throw new Error(result.message || 'Failed to load areas');
        }

        const areas = result.data;
        const areasList = document.getElementById('areasList');
        
        if (!areas || areas.length === 0) {
          console.log('No areas found');
          areasList.innerHTML = '<li class="no-areas">No areas enrolled yet. Click "Enroll New Location" to get started.</li>';
          return;
        }

        console.log(`Found ${areas.length} areas`);
        areasList.innerHTML = '';
        areas.forEach((area, index) => {
          const listItem = document.createElement('li');
          listItem.className = 'area-list-item';
          listItem.innerHTML = `
            <div class="area-info">
              <div class="area-title">Area #${index + 1}</div>
              <div class="area-date">Enrolled on: ${new Date(area.created_at).toLocaleDateString()}</div>
            </div>
            <div>
              <button class="btn-view-details" onclick="showAreaDetails(${JSON.stringify(area).replace(/"/g, '&quot;')})">View Details</button>
              <button class="btn-check-availability" onclick="checkBuildingAvailability(${JSON.stringify(area).replace(/"/g, '&quot;')})">Check Building Availability</button>
            </div>
          `;
          
          listItem.addEventListener('click', () => showAreaOnMap(area));
          areasList.appendChild(listItem);
        });
      } catch (error) {
        console.error('Error loading areas:', error);
        const areasList = document.getElementById('areasList');
        areasList.innerHTML = `
          <li class="no-areas">
            Error loading areas. Please try refreshing the page.
            <br>
            <small style="color: #666;">${error.message}</small>
          </li>
        `;
      }
    }

    // Show specific area on main map
    function showAreaOnMap(area) {
      if (!map) {
        initMap();
      }
      
      const mapContainer = document.getElementById('mapContainer');
      mapContainer.style.display = 'block';
      
      // Initialize layers if they don't exist
      if (!drawnItems) {
        drawnItems = new L.FeatureGroup();
        map.addLayer(drawnItems);
      }
      if (!treeMarkers) {
        treeMarkers = L.layerGroup();
        map.addLayer(treeMarkers);
      }
      
      // Clear existing layers - check if initialized first
      if (drawnItems) drawnItems.clearLayers();
      if (treeMarkers) treeMarkers.clearLayers();
      
      // Add the selected area to the map
      const polygon = L.polygon(area.coordinates, {color: '#0a8806'});
      drawnItems.addLayer(polygon);
      map.fitBounds(polygon.getBounds());
      
      // Update active state in the list (if element exists)
      const areaElement = document.querySelector(`#area-map-${area.id}`);
      if (areaElement) {
        const areaCards = document.querySelectorAll('.area-card');
        areaCards.forEach(card => card.classList.remove('active'));
        areaElement.closest('.area-card').classList.add('active');
      }
      
      // Store active area
      activeArea = area;
      
      // Load trees for this area
      loadTreesForArea(area);
      
      // Add or update availability overlay button
      const mapActions = document.querySelector('.map-actions');
      let availabilityButton = document.getElementById('btnShowAvailability');
      
      // Remove any existing button to avoid duplicates
      if (availabilityButton) {
        availabilityButton.remove();
      }
      
      // Create a new button
      availabilityButton = document.createElement('button');
      availabilityButton.id = 'btnShowAvailability';
      availabilityButton.className = 'btn-show-availability';
      
      // Set text based on current overlay state
      const isOverlayActive = availabilityOverlay && availabilityOverlay.getLayers().length > 0;
      availabilityButton.textContent = isOverlayActive ? 'Hide Building Availability' : 'Show Building Availability';
      
      // Add appropriate class based on state
      if (isOverlayActive) {
        availabilityButton.classList.add('active');
      } else {
        availabilityButton.classList.remove('active');
      }
      
      // Set click handler
      availabilityButton.addEventListener('click', () => showAvailabilityOverlay(area));
      
      // Add to map actions
      mapActions.appendChild(availabilityButton);
      console.log("Availability button added/updated:", availabilityButton.textContent);
    }

    // Load trees for specific area
    async function loadTreesForArea(area) {
      try {
        // Make sure treeMarkers is initialized properly
        if (!treeMarkers) {
          treeMarkers = L.layerGroup();
          if (map) map.addLayer(treeMarkers);
        }
        
        // Clear existing tree markers if treeMarkers exists
        if (treeMarkers) {
          treeMarkers.clearLayers();
        }

        const response = await fetch(`get_trees.php`, {
          headers: {
            'Authorization': `Bearer ${localStorage.getItem('authToken')}`,
            'X-User-ID': localStorage.getItem('user_id')
          }
        });

        // Check if the response is OK before proceeding
        if (!response.ok) {
          console.error("HTTP error:", response.status, response.statusText);
          const errorText = await response.text();
          console.error("Response text:", errorText);
          throw new Error(`Server returned ${response.status}: ${response.statusText}`);
        }

        // Check if the response is JSON
        const contentType = response.headers.get("content-type");
        if (!contentType || !contentType.includes("application/json")) {
          // Handle non-JSON response
          const text = await response.text();
          console.error("Received non-JSON response:", text);
          throw new Error("Server returned an invalid response format");
        }

        // Parse JSON response
        let data;
        try {
          data = await response.json();
        } catch (parseError) {
          console.error("JSON parse error:", parseError);
          throw new Error("Failed to parse JSON response");
        }

        // Handle successful data response
        if (data && data.success) {
          // Add tree markers for trees within the area
          let treeCount = 0;
          if (Array.isArray(data.data)) {
            data.data.forEach(tree => {
              if (isPointInPolygon([tree.lat, tree.lng], area.coordinates)) {
                treeCount++;
                const marker = L.marker([tree.lat, tree.lng], {
                  icon: L.divIcon({
                    className: 'tree-marker',
                    iconSize: [12, 12],
                    html: '<div style="background-color: #0a8806; border: 2px solid white; border-radius: 50%; width: 12px; height: 12px; box-shadow: 0 0 4px rgba(0,0,0,0.3);"></div>'
                  })
                }).bindPopup(`
                  <div style="min-width: 200px;">
                    <strong style="color: #0a8806; font-size: 1.1em;">${tree.type}</strong>
                    <br>
                    ${tree.description ? `<p style="margin: 5px 0;">${tree.description}</p>` : ''}
                    ${tree.photo_path ? `<img src="${tree.photo_path}" alt="Tree Photo" style="width: 100%; border-radius: 4px; margin-top: 5px;">` : ''}
                    <p style="margin: 5px 0; font-size: 0.9em; color: #666;">Added: ${new Date(tree.created_at).toLocaleDateString()}</p>
                  </div>
                `, {
                  maxWidth: 300,
                  className: 'tree-popup'
                });
                treeMarkers.addLayer(marker);
              }
            });
          } else {
            console.warn("data.data is not an array:", data.data);
          }

          // Update tree count in the UI if needed
          const treeCountElement = document.getElementById('treeCount');
          if (treeCountElement) {
            treeCountElement.textContent = treeCount;
          }

          console.log(`Added ${treeCount} tree markers to the map`);
        } else {
          console.error("API returned error:", data?.message || "Unknown error");
        }
      } catch (error) {
        console.error('Error loading trees:', error);
        // Don't alert, just log the error
        // alert('Failed to load trees for this area');
      }
    }

    // Helper function to check if a point is inside a polygon
    function isPointInPolygon(point, polygon) {
      console.log("Checking if point is in polygon:", point, polygon);
      
      // Ensure we have valid inputs
      if (!point || !polygon || !Array.isArray(point) || !Array.isArray(polygon) || polygon.length < 3) {
        console.error("Invalid inputs for isPointInPolygon");
        return false;
      }
      
      const x = point[0], y = point[1];
      let inside = false;
      
      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const xi = polygon[i][0], yi = polygon[i][1];
        const xj = polygon[j][0], yj = polygon[j][1];
        
        const intersect = ((yi > y) !== (yj > y))
          && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
      }
      
      console.log("Point is inside polygon:", inside);
      return inside;
    }

    // Calculate perimeter of a polygon
    function calculatePerimeter(coordinates) {
      let perimeter = 0;
      for (let i = 0; i < coordinates.length; i++) {
        const j = (i + 1) % coordinates.length;
        const dx = coordinates[j][0] - coordinates[i][0];
        const dy = coordinates[j][1] - coordinates[i][1];
        perimeter += Math.sqrt(dx * dx + dy * dy) * 111319.9; // Convert to meters
      }
      return Math.round(perimeter);
    }

    // Calculate area of a polygon
    function calculateArea(coordinates) {
      let area = 0;
      for (let i = 0; i < coordinates.length; i++) {
        const j = (i + 1) % coordinates.length;
        area += coordinates[i][0] * coordinates[j][1];
        area -= coordinates[j][0] * coordinates[i][1];
      }
      area = Math.abs(area) * 111319.9 * 111319.9 / 2; // Convert to square meters
      return Math.round(area);
    }

    // Show area details in modal
    async function showAreaDetails(area) {
      try {
        const modal = document.getElementById('areaModal');
        const modalTitle = document.getElementById('modalTitle');
        const perimeterValue = document.getElementById('perimeterValue');
        const areaValue = document.getElementById('areaValue');
        const treeCountValue = document.getElementById('treeCountValue');
        const treeGrid = document.getElementById('treeGrid');
        const treeDetails = document.getElementById('treeDetails');
        const backButton = document.getElementById('backToTypes');

        modalTitle.textContent = `Area Details`;
        modal.style.display = 'block';
        treeDetails.style.display = 'none';
        backButton.style.display = 'none';
        treeGrid.style.display = 'grid';
